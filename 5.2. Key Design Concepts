 5.2. Key Design Concepts
 5.2. 设计的关键概念

Good design depends on understanding a handful of key concepts. This section discusses the role of complexity, desirable characteristics of designs, and levels of design.
要想做出好的设计就得理解几个关键概念，如这一部分讨论“复杂性（complexity）”，、“设计所需的特性”和“设计的层次”这些概念。

Software's Primary Technical Imperative: Managing Complexity (n.复杂性，错综复杂的状态;复杂的事物;复合物)

Software's Primary Technical Imperative: Managing Complexity 软件主要的技术性必要因素：掌控复杂性。
To understand the importance of managing complexity, it's useful to refer to Fred Brooks's landmark paper, "No Silver Bullets: Essence and Accidents of Software Engineering" (1987).
为了理解掌控复杂性的重要性，就不得不提 Fred Brooks的具有里程碑意义的论文：No Silver Bullets: Essence and Accidents of Software Engineering(1987)
    Cross-Reference  参照
        For discussion of the way complexity affects programming issues other than design, see Section 34.1, "Conquer Complexity."
        关于复杂性比其他设计要点更影响编程的讨论，请查看 section 34.1 "征服complexity"

Accidental and Essential Difficulties   偶然和必然的困境。
    Brooks argues that software development is made difficult because of two different classes of problems—the essential and the accidental.
In referring to these two terms, Brooks draws on a philosophical tradition going back to Aristotle. In philosophy, the essential properties are the properties that a thing must have
 in order to be that thing. A car must have an engine, wheels, and doors to be a car. If it doesn't have any of those essential properties, it isn't really a car.

Accidental properties are the properties a thing just happens to have, properties that don't really bear on whether the thing is what it is. A car could have a V8, a turbocharged 4-cylinder, or some other kind of
engine and be a car regardless of that detail. A car could have two doors or four; it could have skinny wheels or mag wheels. All those details are accidental properties. You could also think of
accidental properties as incidental, discretionary, optional, and happenstance.
    Brooks认为说软件开发是困难的。因为这里有两类亟待解决的问题--必然性问题和偶然性问题。在谈到这两个问题的时候，Brooks借用了一个可以追溯到古罗马时期的哲学术语;在哲学领域，必然属性是一个事物之所以称之为此事物
的必不可少的属性，例如一个汽车必须要有引擎、轮子和车门，这样才能被称之为汽车。如果它没有这些必然属性中的任何一个，它就不能被称之为汽车。
偶然属性是一个事物恰好有的（没有也没有关系)属性，它们并不决定这个事物是什么。例如一个汽车可以有一个V8或者一个涡轮增压四缸发动机，或者一个其他类型的发动机和其他一些可忽略的细节;或者可以有两个或者四个门；可以有有皮轮或者
磁铁轮，所有这些细节都是偶然属性。你也可以把偶然属性认为是附带的，任意的，随意的，和偶然的。

Brooks observes that the major accidental difficulties in software were addressed long ago. For example, accidental difficulties related to clumsy language syntaxes were largely eliminated
in the evolution from assembly language to third-generation languages and have declined in significance incrementally since then. Accidental difficulties related to noninteractive
computers were resolved when time-share operating systems replaced batch-mode systems. Integrated programming environments further eliminated inefficiencies in programming work arising from tools that
worked poorly together.
    Brooks指出，软件中的大部分偶然性困难在很久以前就解决了。例如，从汇编语言到第三代语言的演变过程中，与笨拙的语言的语法相关的偶然性困难在很大程度上已经消除了，并且从那时起这些困难显著的逐渐减少，而当分时操作系统取代批处理
模式系统之后，集成编程工具进一步提高了编程效率。

    Cross-Reference
        Accidental difficulties are more prominent in early-wave development than in late-wave development. For details, see Section 4.3, "Your Location on the Technology Wave."

Brooks argues that progress on software's remaining essential difficulties is bound to be slower. The reason is that, at its essence, software development consists of working out all the details of a highly
 intricate, interlocking set of concepts. The essential difficulties arise from the necessity of interfacing with the complex, disorderly real world; accurately and completely identifying the dependencies and
exception cases; designing solutions that can't be just approximately correct but that must be exactly correct; and so on. Even if we could invent a programming language that used the same terminology as the
real-world problem we're trying to solve, programming would still be difficult because of the challenge in determining precisely how the real world works. As software addresses ever-larger real-world problems,
 the interactions among the real-world entities become increasingly intricate, and that in turn increases the essential difficulty of the software solutions.
The root of all these essential difficulties is complexity—both accidental and essential.
Brooks认为，软件开发中仍然存在的必然性困难的解决过程必然会很慢，因为究其本质，软件是高度复杂的、概念互锁的概念 集合，软件开发必须实现其中所有的细节。必要性的困难源自于 与复杂的、无序的现实世界的接口的必要性；准确、完全的分辨出依赖关系和例外/异常案例，
设计的解决方案不能只是近似正确的，而是必须是完全正确的等等。即使我们可以发明一种编程语言，使用与我们正在试图解决的现实世界中的问题的相同术语，编程仍然是困难的，因为如何精确确定现实世界是如何运行的依然困难。随着软件解决了越来越大的现实世界的问题
，现实世界中的实体之间的相互作用变得越来越复杂，这反过来又增加了软件解决方案的必然性的难度。所有这些基本困难的根源都是偶然和必然/本质的复杂性。
Importance of Managing Complexity  掌控复杂性的重要性
When software-project surveys report causes of project failure, they rarely identify technical reasons as the primary causes of project failure. Projects fail most often because of poor requirements,
poor planning, or poor management. But when projects do fail for reasons that are primarily technical, the reason is often uncontrolled complexity. The software is allowed to grow so complex that no one really
knows what it does. When a project reaches the point at which no one completely understands the impact that code changes in one area will have on other areas, progress grinds to a halt.

There are two ways of constructing a software design: one way is to make it so simple that there are obviously no deficiencies, and the other is to make it so complicated that there are no obvious
deficiencies.
软件项目调查显示，软件失败的主要原因并非技术原因。而经常是因为需求简陋、无计划或者无/混乱管理。但是当确实是技术原因导致的失败，往往是由复杂性的不可控引起的。软件被允许复杂到谁都不知道它是做什么的。当一个工程复杂到谁都不能完全了解改变一个
区域内的代码将带来什么影响的境地，进程停顿。
构建一个软件设计的方法有两种：一种是使软件设计简单，明显没有缺陷，另一种是使软件设计复杂，没有明显的缺陷。

—C. A. R. Hoare
 	Managing complexity is the most important technical topic in software development. In my view, it's so important that Software's Primary Technical Imperative has to be managing complexity.

-C.A.R.Hoare
掌控复杂性是在软件开发中的最重要的技术话题。在我看来，它是如此之重要，所以软件的主要技术必须是管理复杂性（managine complexity）。
Complexity is not a new feature of software development. Computing pioneer Edsger Dijkstra pointed out that computing is the only profession in which a single mind is obliged to span the distance from
a bit to a few hundred megabytes, a ratio of 1 to 109, or nine orders of magnitude (Dijkstra 1989). This gigantic ratio is staggering. Dijkstra put it this way: "Compared to that number of semantic levels,
the average mathematical theory is almost flat. By evoking the need for deep conceptual hierarchies, the automatic computer confronts us with a radically new intellectual challenge that has no precedent
in our history." Of course software has become even more complex since 1989, and Dijkstra's ratio of 1 to 109could easily be more like 1 to 1015 today.

Dijkstra pointed out that no one's skull is really big enough to contain a modern computer program (Dijkstra 1972), which means that we as software developers shouldn't try to cram whole programs into our
skulls at once; we should try to organize our programs in such a way that we can safely focus on one part of it at a time. The goal is to minimize the amount of a program you have to think about at any one
time. You might think of this as mental juggling—the more mental balls the program requires you to keep in the air at once, the more likely you'll drop one of the balls, leading to a design or coding error.

One symptom that you have bogged down in complexity overload is when you find yourself doggedly applying a method that is clearly irrelevant, at least to any outside observer. It is like the mechanically
 inept person whose car breaks down—so he puts water in the battery and empties the ashtrays.
—P. J. Plauger

At the software-architecture level, the complexity of a problem is reduced by dividing the system into subsystems. Humans have an easier time comprehending several simple pieces of information than one
complicated piece. The goal of all software-design techniques is to break a complicated problem into simple pieces. The more independent the subsystems are, the more you make it safe to focus on one bit
of complexity at a time. Carefully defined objects separate concerns so that you can focus on one thing at a time. Packages provide the same benefit at a higher level of aggregation.
Keeping routines short helps reduce your mental workload. Writing programs in terms of the problem domain, rather than in terms of low-level implementation details, and working at the highest level of
abstraction reduce the load on your brain.
The bottom line is that programmers who compensate for inherent human limitations write code that's easier for themselves and others to understand and that has fewer errors.
复杂性并不是软件开发的新特性。计算机先驱 Edsger Dijkstra指出 计算机是唯一的一个可以让一个人的思想从1比特跨越到几百兆、1比109、或者九个数量级（Dijkstra 1972）。这个比例是惊人的。Dijkstra这样说：“”；当然，自从1989年之后，软件
变得更加复杂，Dijkstra的1比109的速率在当今以后能轻易变成1比1015.
Dijkstra指出没有一个人的脑袋能够大到装下一个现代计算机程序（Dijkstra 1972），这意味着，作为程序开发者的我们不应该试图一下子把程序装进我们的大脑；我们应该试着用一种一次只关注一部分的方法来组织我们的程序。目标是在任何一次思考的时候都
最小化程序的数量。你可能认为这是心理欺骗----程序要求你一次保持在空中的球越多，你越可能失掉其中的一个球，这将导致设计或者编码错误。

//一个症状，你已经陷入复杂的过载是当你发现自己的固执的应用显然是不相干的方法，至少在任何外界的观察者。它像机械无能的人的车坏了，所以他把水在电池和清空烟灰缸。
你已经陷入复杂性陷阱的一个征兆就是你发现你自己固执的应用一个完全不相干的方法，至少对外界的观察者看来如此。这就像一个不懂机械修理的人，他的车抛锚了，结果他在电池里注水和清空了烟灰缸。

在软件架构层次，通过把一个系统分割成子系统能降低问题复杂性。相比于一个复杂的信息块，人类更容易理解几个简单的信息块。所有软件设计技术的目标都是把一个复杂的问题转化成简单的几个小问题块。子系统的依赖性越低，你就能越安全的专注于一个稍微复杂
的过程。仔细的定义对象单独的对象以便你能每次都专注于一件事。包在聚合层次提供了同样的好处。保持历程简短能帮你减少脑力负荷。在问题领域编程而不是在更低层次上去实现细节，并在最高级别的抽象模型上工作能较少你的脑力负担。
底线是，程序员谁弥补人的固有限制，写更容易为自己和其他人理解的代码并且有更少的错误。
How to Attack Complexity 如何攻击复杂性
Overly costly, ineffective designs arise from three sources: 代价高昂，低效的设计来源于三个方面：
•	A complex solution to a simple problem                   问题简单却设计复杂
•	A simple, incorrect solution to a complex problem        简单却不正确的对复杂问题的设计
•	An inappropriate, complex solution to a complex problem  不合适的，复杂的对复杂问题的设计。

As Dijkstra pointed out, modern software is inherently complex, and no matter how hard you try, you'll eventually bump into some level of complexity that's inherent in the real-world problem itself.
This suggests a two-prong approach to managing complexity:
•	 Minimize the amount of essential complexity that anyone's brain has to deal with at any one time.
•	Keep accidental complexity from needlessly proliferating.
就像Dijkstra指出的，现代软件本质上都是复杂的。不管你多么努力，你总会碰到一些一定水平的复杂性--他们在现实世界本身就是复杂的。
这里建议两种方法来管理复杂性。
简化基本的复杂性让每个人一次就可以处理
保持偶发复杂性避免无谓的增殖
Once you understand that all other technical goals in software are secondary to managing complexity, many design considerations become straightforward.
一旦你理解软件中的所有技术目标都是其次与管理复杂性，许多设计上的考虑就变得简单明了了。


Desirable Characteristics of a Design  设计的理想特性
A high-quality design has several general characteristics. If you could achieve all these goals, your design would be very good indeed. Some goals contradict other goals, but that's the challenge of
design—creating a good set of tradeoffs from competing objectives. Some characteristics of design quality are also characteristics of a good program: reliability, performance, and so on. Others are internal
characteristics of the design.
When I am working on a problem I never think about beauty. I think only how to solve the problem. But when I have finished, if the solution is not beautiful, I know it is wrong.
—R. Buckminster Fuller
Here's a list of internal design characteristics:
高质量的设计包含几个典型特征。如果你能实现所有的目标，你的设计实际上将十分棒。一些设计目标和其他目标有冲突，但是这就是设计的魅力--在竞争中创造平衡。设计的一些好的特性也是一个好的程序的特性：可靠性、高性能等等。其他的都是设计的内部特征。
当我在解决问题的时候我从不考虑它是否优雅。我只是在想如何去解决它。但是当我完成之后，如果解决方案不优雅，我就知道他是错的  --R. Buckminster Fuller.
这里是设计的内部特性的列表：
Cross-Reference
These characteristics are related to general software-quality attributes. For details on general attributes, see Section 20.1, "Characteristics of Software Quality."
引用：
这些特性和基本的软件质量的属性有关，更多基本属性的细节参看20.1节， “软件的质量的特性”。
Minimal complexity
The primary goal of design should be to minimize complexity for all the reasons just described. Avoid making "clever" designs. Clever designs are usually hard to understand. Instead make "simple" and
 "easy-to-understand" designs. If your design doesn't let you safely ignore most other parts of the program when you're immersed in one specific part, the design isn't doing its job.

Ease of maintenance
Ease of maintenance means designing for the maintenance programmer. Continually imagine the questions a maintenance programmer would ask about the code you're writing. Think of the maintenance programmer
as your audience, and then design the system to be self-explanatory.
Loose coupling
Loose coupling means designing so that you hold connections among different parts of a program to a minimum. Use the principles of good abstractions in class interfaces, encapsulation, and information
hiding to design classes with as few interconnections as possible. Minimal connectedness minimizes work during integration, testing, and maintenance.
Extensibility
Extensibility means that you can enhance a system without causing violence to the underlying structure. You can change a piece of a system without affecting other pieces.
The most likely changes cause the system the least trauma.
Reusability
Reusability means designing the system so that you can reuse pieces of it in other systems.
High fan-in
High fan-in refers to having a high number of classes that use a given class. High fan-in implies that a system has been designed to make good use of utility classes at the lower levels in the system.
Low-to-medium fan-out
Low-to-medium fan-out means having a given class use a low-to-medium number of other classes. High fan-out (more than about seven) indicates that a class uses a large number of other classes and
may therefore be overly complex. Researchers have found that the principle of low fan-out is beneficial whether you're considering the number of routines called from within a routine or from within
a class (Card and Glass 1990; Basili, Briand, and Melo 1996).

Portability
Portability means designing the system so that you can easily move it to another environment.
Leanness
Leanness means designing the system so that it has no extra parts (Wirth 1995, McConnell 1997). Voltaire said that a book is finished not when nothing more can be added but when nothing more can be taken
 away. In software, this is especially true because extra code has to be developed, reviewed, tested, and considered when the other code is modified. Future versions of the software must remain
backward-compatible with the extra code. The fatal question is "It's easy, so what will we hurt by putting it in?"

Stratification
Stratification means trying to keep the levels of decomposition stratified so that you can view the system at any single level and get a consistent view. Design the system so that you can view it
at one level without dipping into other levels.
For example, if you're writing a modern system that has to use a lot of older, poorly designed code, write a layer of the new system that's responsible for interfacing with the old code.
Design the layer so that it hides the poor quality of the old code, presenting a consistent set of services to the newer layers. Then have the rest of the system use those classes rather than the old code.
 The beneficial effects of stratified design in such a case are (1) it compartmentalizes the messiness of the bad code and (2) if you're ever allowed to jettison the old code or refactor it, you won't
need to modify any new code except the interface layer.
把复杂性最小化。
如前所述种种，设计的主要目的就是把复杂性最小化。避免进行“聪明”的设计。聪明的设计通常是很难理解的。相反，使用“简单”和“容易理解”的设计。当你沉浸在程序的一个特定部分的时候，如果你的设计不能让你安全地忽略程序的其余的大部分，，那么你的设
计是不好的设计。
易于维护
易于维护意味着在设计的时候为程序维护人员考虑周到。不断想象一个维护程序员会问你正在写的代码的问题。把维护程序员当作你的听众，然后设计一个能不言自明的系统。

松耦合
松耦合意味着使一个程序的不同部分之间的连接达到最低限度。使用良好的抽象类的接口，封装和信息隐藏的原则，尽可能少的设计类的互联。最小连通性、最大限度地减少集成，测试和维护工作。

可扩展性
扩展意味着你可以增强一个系统而不引起对底层结构的歪曲。你可以改变一个系统的一部分而不会影响系统的其他部分。最大可能的改变最小的创伤。

可重用性
重用意味着您可以让其他系统重用你设计的系统。

高扇入
高扇入是指有大量的类使用一个给定的类。高扇入意味着这个被设计的系统充分的使用了较低层次的实用类。

低到中等的扇出
低到中等的扇出输出意味着一个给定的类使用一个低到中等数量的其他类。高扇出（超过约七）表示一个类使用了大量的其他类，因此可能是过于复杂的。研究人员发现，低扇出原则是有益的--不管你你是否考虑到一个历程调用的例程的数量 或者 一个调用的历程的数量(Card and Glass 1990; Basili, Briand, and Melo 1996)。

可移植性
可移植性您可以轻松地将它移动到另一个环境。

精简（精益求精）
精简意味着没有多余的部分（Wirth 1995, McConnell 1997）。Voltaire说，一本书完成后，不是没有什么可以补充，而是没有什么可以删减。在软件中，这是特别正确的，因为额外的代码必须开发，审查，测试在其他代码被修改时重新考虑。
未来版本的软件必须与额外的代码保持向后兼容。致命的问题是“它很容易，但所以我们把它放在进来会受到伤害？”

分层
分层意味着要保持分解的分层数目得到满足，这样你就可以在任何一个层次上查看系统并获得一致的视图。设计该系统，以便您可以在每一个层级上查看的到而不浸渍到其他层级。

例如，如果你正在写一个现代的系统，这个系统必须使用大量的旧的、设计差的代码，写一个新的系统，负责与旧代码接口。设计的一层隐藏了低质量的旧代码，提出了一组一致的服务。然后有其他的系统使用这些中间类，而不是旧的代码。
分层设计原则在这种情况下的好处是：（1）它划分了混乱和糟糕的代码（2）如果你可以抛弃旧代码或重构它，你不需要修改任何代码除了界面层。

Cross-Reference
For more on working with old systems, see Section 24.5, "Refactoring Strategies."

Standard techniques
The more a system relies on exotic pieces, the more intimidating it will be for someone trying to understand it the first time. Try to give the whole system a familiar feeling by using standardized,
common approaches.
Cross-Reference
An especially valuable kind of standardization is the use of design patterns, which are discussed in "Look for Common Design Patterns" in Section 5.3.

Levels of Design
Design is needed at several different levels of detail in a software system. Some design techniques apply at all levels, and some apply at only one or two. Figure 5-2 illustrates the levels.
Figure 5-2. The levels of design in a program. The system (1) is first organized into subsystems (2). The subsystems are further divided into classes (3), and the classes are divided into
routines and data (4). The inside of each routine is also designed (5)
[View full size image]
标准技术
一个系统设计的越奇特（不符合通用标准），第一次尝试去理解它的时候越困难。请尝试使用标准化来让整个系统给人一种熟悉感。

引用
    一个特别有价值的标准化是使用设计模式，这是在“寻找共同的设计模式”，第5.3节中讨论的。

设计的层次

在软件系统中的把设计分为几个不同的设计层次是必要的。一些设计技术适用于各个层次，一些适用于一个或两个层次。图5-2说明。

图5-2。

程序中的设计层次。

该系统（1）首先被组织成子系统（2）子系统进一步分为类（3）类分为子程序和数据（4）每个程序的内部也被类似的进行了设计（5）

[查看全尺寸图像]

Level 1: Software System
The first level is the entire system. Some programmers jump right from the system level into designing classes, but it's usually beneficial to think through higher level combinations of classes, such as
subsystems or packages.
In other words—and this is the rock-solid principle on which the whole of the Corporation's Galaxywide success is founded—their fundamental design flaws are completely hidden by their superficial design
、flaws.—Douglas Adams
层次1：软件系统
第一个层次是整个系统。一些程序员直接从系统级层次跳到设计类层次，但是通过更高层次的类，如子系统或包来思考通常更有好处。
换句话说--这是坚如磐石的原则。在这个原则上，公司的 全银河系的成功被奠定了---通过他们自己的肤浅的设计、缺陷，基本的设计缺陷被完全隐藏- Douglas Adams一

Level 2: Division into Subsystems or Packages
The main product of design at this level is the identification of all major subsystems. The subsystems can be big: database, user interface, business rules, command interpreter, report engine, and so on.
The major design activity at this level is deciding how to partition the program into major subsystems and defining how each subsystem is allowed to use each other subsystem. Division at this level is
typically needed on any project that takes longer than a few weeks. Within each subsystem, different methods of design might be used—choosing the approach that best fits each part of the system.
In Figure 5-2, design at this level is marked with a 2.
Of particular importance at this level are the rules about how the various subsystems can communicate. If all subsystems can communicate with all other subsystems, you lose the benefit of separating
them at all. Make each subsystem meaningful by restricting communications.

Suppose for example that you define a system with six subsystems, as shown in Figure 5-3. When there are no rules, the second law of thermodynamics will come into play and the entropy of the system will
increase. One way in which entropy increases is that, without any restrictions on communications among subsystems, communication will occur in an unrestricted way, as in Figure 5-4.

Figure 5-3. An example of a system with six subsystems
[View full size image]
层次2：分为子系统或者包
这个层次的设计的主要是识别出所有的主要子系统。子系统可以很大：数据库、用户接口、商业条例、命令行交互，报表引擎等等。这个层级的主要设计行为是决定如何把程序分解为子系统并定义好每个子系统被允许使用其他的子系统。这个层次的拆分
最长几个星期。在每个子系统中，不同的设计方法都可能被采用--选择最适合系统各个部分的解决方案。参见图5-2 a 2.
这个层级尤其重要的是各个子系统如何交互。如果所有的子系统都能和所有的其他子系统交互，你就失去了隔离他们的机会。通过严格限制通信来使系统有意义。
你用六个子系统定义了一个系统。如图5-3所示。

Figure 5-4. An example of what happens with no restrictions on intersubsystem communications
[View full size image]


As you can see, every subsystem ends up communicating directly with every other subsystem, which raises some important questions:
•	How many different parts of the system does a developer need to understand at least a little bit to change something in the graphics subsystem?
•	What happens when you try to use the business rules in another system?
•	What happens when you want to put a new user interface on the system, perhaps a command-line UI for test purposes?
•	What happens when you want to put data storage on a remote machine?
    You might think of the lines between subsystems as being hoses with water running through them. If you want to reach in and pull out a subsystem, that subsystem is going to have some hoses attached to it. The more hoses you have to disconnect and reconnect, the more wet you're going to get. You want to architect your system so that if you pull out a subsystem to use elsewhere, you won't have many hoses to reconnect and those hoses will reconnect easily.
With forethought, all of these issues can be addressed with little extra work. Allow communication between subsystems only on a "need to know" basis—and it had better be a good reason. If in doubt, it's easier to restrict communication early and relax it later than it is to relax it early and then try to tighten it up after you've coded several hundred intersubsystem calls. Figure 5-5 shows how a few communication guidelines could change the system depicted in Figure 5-4.
Figure 5-5. With a few communication rules, you can simplify subsystem interactions significantly
[View full size image]

如你所见，每个子系统的目的就是和其他子系统直接通信，那么问题来了：
  在图形子系统中，一个开发者如果需要修改一些东西，他需要了解/理解系统的多少个部分。
  在另一个系统中，当你使用商业原则的时候什么发生了。
  当你尝试把一个新的用户接口放到系统中的时候，发生了什么？可能是一个为了测试目的而存在的命令行UI？
   当你尝试把数据存储放到远端机器上的时候发生了什么
To keep the connections easy to understand and maintain, err on the side of simple intersubsystem relations. The simplest relationship is to have one subsystem call routines in another. A more
involved relationship is to have one subsystem contain classes from another. The most involved relationship is to have classes in one subsystem inherit from classes in another.

A good general rule is that a system-level diagram like Figure 5-5 should be an acyclic graph. In other words, a program shouldn't contain any circular relationships in which Class A uses Class B,
Class B uses Class C, and Class C uses Class A.

On large programs and families of programs, design at the subsystem level makes a difference. If you believe that your program is small enough to skip subsystem-level design, at least make the decision
to skip that level of design a conscious one.

Common Subsystems
Some kinds of subsystems appear again and again in different systems. Here are some of the usual suspects.
Business rules
Business rules are the laws, regulations, policies, and procedures that you encode into a computer system. If you're writing a payroll system, you might encode rules from the IRS about the number of
allowable withholdings and the estimated tax rate. Additional rules for a payroll system might come from a union contract specifying overtime rates, vacation and holiday pay, and so on.
If you're writing a program to quote automobile insurance rates, rules might come from government regulations on required liability coverages, actuarial rate tables, or underwriting restrictions
为了保持连接通俗易懂、容易实现，错误 放在简单交互子系统关系中。最简单的关系就是一个子系统调用另一个子系统中的例程。稍微复杂一些的关系就是让一个子系统包含另一个子系统的类们。最复杂的关系是集成另一个子系统中的类们。
一个好的基本规则就是像例5-5所示的系统级的图标必须是有向无环图。换句话说，一个程序必须不包含任何类似于 A类使用B类，B类使用C类，C类又使用A类这样的环。

在大型程序和程序组中，子系统级别的设计各不相同。如果你认为你的程序笑道可以忽略子系统级别上的设计，那么至少得下掉决心 忽略设计水平对这个的设计。
公共子系统
一些子系统好像频繁的出现在不同的系统中，这里有一些常见的疑点.
Business Rules
Business Rules是当你在计算机系统中编程时的法律、法规、政策和程序。如果你正在写一个工资管理系统，你可能编码从IRS得到的关于抠脚和预估税率xxxx的规则。工资系统的附加规则可能来自一个联盟合同，合同中制定加班费率、假期和假日工资，等等。
如果你写一个程序引用的汽车保险费率，规则可能来自政府要求的责任险规定，精算费率表，或承保的限制
Cross-Reference
For more on simplifying business logic by expressing it in tables, see Chapter 18, "Table-Driven Methods."
对于更多的简化业务逻辑，通过在表中表达它，请参见第18章“表驱动的方法”。
User interface
Create a subsystem to isolate user-interface components so that the user interface can evolve without damaging the rest of the program. In most cases, a user-interface subsystem uses
several subordinate subsystems or classes for the GUI interface, command line interface, menu operations, window management, help system, and so forth.

Database access
You can hide the implementation details of accessing a database so that most of the program doesn't need to worry about the messy details of manipulating low-level structures and can deal with the data
in terms of how it's used at the business-problem level. Subsystems that hide implementation details provide a valuable level of abstraction that reduces a program's complexity. They centralize database
operations in one place and reduce the chance of errors in working with the data. They make it easy to change the database design structure without changing most of the program.
System dependencies Package operating-system dependencies into a subsystem for the same reason you package hardware dependencies. If you're developing a program for Microsoft Windows, for example,
why limit yourself to the Windows environment? Isolate the Windows calls in a Windows-interface subsystem. If you later want to move your program to Mac OS or Linux, all you'll have to change is the
 interface subsystem. An interface subsystem can be too extensive for you to implement on your own, but such subsystems are readily available in any of several commercial code libraries.
用户接口
创建一个子系统来隔离用户接口组件，使用户接口可以进化而不破坏程序的其余部分。在大多数情况下，用户接口子系统使用几个下属子系统或类来为图形界面，命令行界面，菜单操作，窗口管理，帮助系统服务，等等。

数据库访问
可以隐藏访问数据库的实现细节 ，使大多数程序不需要担心操作底层结构的混乱细节，并可以处理数据在业务问题级别上的使用情况。隐藏实现细节的子系统提供了一个有价值的抽象层次，降低了程序的复杂性。集中的数据库操作和减少数据工作中
错误的机会。所有这些使得很容易改变数据库设计结构，而不改变大多数程序。

xxxxxxx.例如，如果你为Microsoft Windows开发了一个程序，为什么把你自己限制在Windows环境呢？在windows-interface子系统中隔离windows调用。如果你以后想把你的程序移植到Mac OS或者Linux，你做需要做的修改仅仅是接口子系统。一个接口
子系统可能你自己难以实现，但是有现成的。

Level 3: Division into Classes
Level 3 : 分解成类
Design at this level includes identifying all classes in the system. For example, a database-interface subsystem might be further partitioned into data access classes and persistence framework classes as
well as database metadata. Figure 5-2, Level 3, shows how one of Level 2's subsystems might be divided into classes, and it implies that the other three subsystems shown at Level 2 are also
decomposed into classes.
这个层级的设计包含分辨出系统中的所有类。例如，一个数据库接口子系统可能会进一步分为数据访问类和持久化框架类和数据库元数据。图5-2，3层，展示了2级子系统可能被分解为类，并且他暗示了另外三个子系统--level 2的可能也会分解成类。

Further Reading 进一步阅读
For a good discussion of database design, see Agile Database Techniques (Ambler 2003).
关于数据库的进一步讨论，请查看Agile Database Techniques.
Details of the ways in which each class interacts with the rest of the system are also specified as the classes are specified. In particular, the class's interface is defined. Overall, the major design
 activity at this level is making sure that all the subsystems have been decomposed to a level of detail fine enough that you can implement their parts as individual classes.
The division of subsystems into classes is typically needed on any project that takes longer than a few days. If the project is large, the division is clearly distinct from the program partitioning
of Level 2. If the project is very small, you might move directly from the whole-system view of Level 1 to the classes view of Level 3.
如同类所指定的那样，每个类与系统的其余部分相互交互的方法的细节也被指定。 特别需要提及的是，类的接口被定义。总体而言，这个层级的设计的主要活动是确保所有的子系统都被充分分解以便于你能够把他们都独立的实现为类。
子系统划分为类是任何工程中都需要的，它大概持续几天。如果项目比较大，会于level 2 有明显的区别，如果项目很小，您可以直接从1级的整个系统视图移动到3级的类视图。

Cross-Reference
For details on characteristics of high-quality classes, see Chapter 6, "Working Classes."
高质量类设计的细节，请查看 第六章 working classes.
Classes vs. Objects  类vs.对象
A key concept in object-oriented design is the differentiation between objects and classes. An object is any specific entity that exists in your program at run time. A class is the static thing you look
 at in the program listing. An object is the dynamic thing with specific values and attributes you see when you run the program. For example, you could declare a class Person that had attributes of name,
age, gender, and so on. At run time you would have the objects nancy, hank, diane, tony, and so on—that is, specific instances of the class. If you're familiar with database terms, it's the same as the
distinction between "schema" and "instance." You could think of the class as the cookie cutter and the object as the cookie. This book uses the terms informally and generally refers to classes and objects
 more or less inter-changeably.
面向对象设计的一个关键概念是类和对象的不同。一个对象object是任何一个在运行时存在于你的程序中的特定的实体。一个类是一个静态的、在程序列表中可见的。一个object是你运行程序的时候有特定值和属性的动态的物体。例如，你能声明一个类Person，有
名字，年龄，性别和其他属性。在运行时，你可以有对象nancy,hank,diane,tony和其他对象，这就是说，类的特定实例。如果你对数据库比较熟悉，这两个的区别就像schema和instance的区别。你可以把class认为是cookie cutter，而object是cookie.

Level 4: Division into Routines
Design at this level includes dividing each class into routines. The class interface defined at Level 3 will define some of the routines. Design at Level 4 will detail the class's private routines.
When you examine the details of the routines inside a class, you can see that many routines are simple boxes but a few are composed of hierarchically organized routines, which require still more design.
The act of fully defining the class's routines often results in a better understanding of the class's interface, and that causes corresponding changes to the interface—that is, changes back at Level 3.
This level of decomposition and design is often left up to the individual programmer, and it's needed on any project that takes more than a few hours. It doesn't need to be done formally,
but it at least needs to be done mentally.
Level 5: Internal Routine Design
Design at the routine level consists of laying out the detailed functionality of the individual routines. Internal routine design is typically left to the individual programmer working on an individual
 routine. The design consists of activities such as writing pseudocode, looking up algorithms in reference books, deciding how to organize the paragraphs of code in a routine, and writing
 programming-language code. This level of design is always done, though sometimes it's done unconsciously and poorly rather than consciously and well. In Figure 5-2, design at this level is marked
 with a 5.
Cross-Reference
For details on creating high-quality routines, see Chapter 7, "High-Quality Routines," and Chapter 8, "Defensive Programming."
level 4:分解成routines
这一层的设计包含把class分解成routines.在level3定义的class接口将定义一些routines.level4的设计将发掘类的私有routines的细节。当你检查clas里的routines的细节，你能看见许多routines是简单的盒子，但是另一些由分层组织的routines构成，
它需要更多的设计。充分定义class的routins常常能导致更好的理解class的接口，这样导致相应的接口的改变--意思是说，导致level 3的改变。分解和设计的层次经常随着变成者的不同而不同。并且他在任何项目上都需要几个小时时间。他不需要形成正式的文档，
但至少需要你在头脑中有个腹稿。

level 5: 内部routine设计
routine级的设计包含列出各个routine的功能细节。内部routine设计通常留给单独的程序员。设计活动通常包含些伪代码，寻算法，决定如何组织代码，并写程序语言代码。这个级别的设计是经常做的，虽然有时候他是不自觉的、劣质的而不是自觉的、良好的。


*/


/*

<?php
/*

5.3. Design Building Blocks: Heuristics 设计积木块：探索式算法
Software developers tend to like our answers cut and dried: "Do A, B, and C, and X, Y, Z will follow every time." We take pride in learning arcane sets of steps that produce desired effects,
and we become annoyed when instructions don't work as advertised. This desire for deterministic behavior is highly appropriate to detailed computer programming, where that kind of strict attention to
detail makes or breaks a program. But software design is a much different story.

Because design is nondeterministic, skillful application of an effective set of heuristics is the core activity in good software design. The following subsections describe a number of heuristics—ways
to think about a design that sometime produce good design insights. You might think of heuristics as the guides for the trials in "trial and error." You undoubtedly have run across some of these before.
Consequently, the following subsections describe each of the heuristics in terms of Software's Primary Technical Imperative: managing complexity.
软件开发人员倾向于直截了当："做A,B和C,并让X,Y,Z每次都跟着执行".我们以能够学到实现所需效果的神秘步骤为荣，以指令没有达到预期为耻。这种对确定性行为的渴望高度符合追求细节的计算机编程，这种对细节的严格关注成就或者挫败了一个程序。
但是软件设计是一个更加不同的故事。

因为设计是不确定的，所以在好的软件设计中，一套行之有效的、探索式的行动方案是设计的核心。在下述的几节中提供了一些探索式的方法，我们用这些方法来思考一个设计；这些方法有时也提供了一些好的设计视角。如果你认为探索式方法是"trial and error"中的trials.
那么，毫无疑问你之前做过其中的一些。下文中讨论的每个启发式算法，总结起来，用计算机的术语来描述就是：掌控复杂性。

Find Real-World Objects  找到现实世界的实体
The first and most popular approach to identifying design alternatives is the "by the book" object-oriented approach, which focuses on identifying real-world and synthetic objects.

第一个和最流行的确定设计方案的方法 是书院派 的面向对象设计方方法，此方法侧重于现实世界的实体和我们人工构建的对象的对应。
Ask not first what the system does; ask WHAT it does it to! —Bertrand Meyer
不要问系统做了什么，问它要做什么！ --Bertrand Meyer
The steps in designing with objects are
    Identify the objects and their attributes (methods and data).
    Determine what can be done to each object.
    Determine what each object is allowed to do to other objects.
    Determine the parts of each object that will be visible to other objects—which parts will be public and which will be private.
    Define each object's public interface.
设计对象的步骤是：
    分辨出对象和他们的属性（方法和数据）
    确定出每个对象能够对其他对象做什么
    确定出每个对象被允许可以对其他对象做什么。
    确定出每个对象可以对其他对象可见的部分--那些是公开的，哪些是私人的。
    确定出每个对象的公共接口。

Cross-Reference
For more details on designing using classes, see Chapter 6, "Working Classes."
These steps aren't necessarily performed in order, and they're often repeated. Iteration is important. Each of these steps is summarized below.
Identify the objects and their attributes Computer programs are usually based on real-world entities. For example, you could base a time-billing system on real-world employees, clients, timecards, and bills.
Figure 5-6 shows an object-oriented view of such a billing system.
Figure 5-6. This billing system is composed of four major objects. The objects have been simplified for this example
引用
有关使用类来进行设计的详细信息，请参见第6章“工作类”。
这些步骤不必按序来做，他们经常重复，因为迭代是重要的。每个步骤在后面章节都有总结。
对象和其属性通常基于现实世界实体，例如，你可以基于现实世界的员工、客户、工卡、票据来设计时间计费系统。
图 5-6  这个计费系统是由四个主要对象组成的，原来的对象已被简化成此例子。
[View full size image]

Identifying the objects' attributes is no more complicated than identifying the objects themselves.
Each object has characteristics that are relevant to the computer program.For example, in the time-billing system, an employee object has a name, a title, and a billing rate. A client object has a name, a billing address, and an account balance.
A bill object has a billing amount, a client name, a billing date, and so on.

Objects in a graphical user interface system would include windows, dialog boxes, buttons, fonts, and drawing tools. Further examination of the problem domain might produce
better choices for software objects than a one-to-one mapping to real-world objects, but the real-world objects are a good place to start.

Determine what can be done to each object
A variety of operations can be performed on each object. In the billing system shown in Figure 5-6, an employee object could have a change in title or billing rate, a client
 object could have its name or billing address changed, and so on.

Determine what each object is allowed to do to other objects
This step is just what it sounds like. The two generic things objects can do to each other are containment and inheritance. Which objects can contain which other objects?
Which objects can inherit from which other objects? In Figure 5-6, a timecard object can contain an employee object and a client object, and a bill can contain one or more timecards.
 In addition, a bill can indicate that a client has been billed, and a client can enter payments against a bill. A more complicated system would include additional interactions.
Determine the parts of each object that will be visible to other objects
One of the key design decisions is identifying the parts of an object that should be made public and those that should be kept private. This decision has to be made for both data
and methods.

确定对象属性不比确定对象本身要容易。每个对象都具有与计算机程序相关的特征。例如在时间计费系统中，一个雇员对象有一个名字，一个标题，一个计费速率；一个客户端对象有一个名称，一个计费地址和一个账户余额；
一个计费对象有一个开票金额，一个客户名称和开票日期。等等。
图形用户接口系统中一个对象包含窗口、对话框、按钮、字体和绘图工具。更进一步的检查思考问题域可能会比一对一的直接映射现实世界的对象产生更好的选择。但是使用现实世界中的实体作为对象是一个很好的开始。
确定能对每个对象做什么
在每个对象上都可以做一系列的操作。在图5-6的计费系统，雇员对象可以对标题或者计费率做修改。一个客户端对象可以对名字和账单地址做修改，等等。


确定每个对象可以对其他对象做什么
如题。对象能够对其他对象做的两件基本的事情是包含和继承。那些对象可以包含其他对象，那些对象能继承自其他对象？在图5-6中，一个工卡对象可以包含一个雇员对象和一个客户端对象，并且一个清单可以包含一个或者多个工卡对象
除此之外，一个清单能表明一个客户端已经被标记，并且客户端能输入对账单支付。一个更复杂的系统将包含更多的交互。
决定可以对其他对象可见的部分
一个设计的关键是区分对象的某一部分是public还是private.这也通用于数据和方法。





Cross-Reference
For details on classes and information hiding, see "Hide Secrets (Information Hiding)" in Section 5.3.

[查看全尺寸图像]
确定对象的属性是没有比识别对象本身更复杂的了。每个对象都具有与计算机程序相关的特性。例如，在时间计费系统中，一个雇员对象有一个名称、一个标题和一个计费速率。一个客户端对象有一个名称、一个计费地址和
一个帐户余额。一个法案的对象有一个开票金额、客户名称、开票日期等。
在一个图形用户界面系统中的对象将包括窗口、对话框、按钮、字体和绘图工具。进一步的检查的问题域可能会产生更好的选择，软件对象比一个一对一的映射到现实世界的对象，但现实世界的对象是一个很好的开始。

确定可以对每个对象做什么样的操作可以在每个对象上执行。图5-6的计费系统显示，雇员对象可以在标题或计费率的变化，客户对象可以有它的名字或地址改变，等等。
确定每一个对象被允许做的其他对象，这一步是什么，它听起来像。两个泛型对象可以互相做的是包含和继承。哪个对象可以包含其他对象？哪个对象可以继承其他对象？图5-6，考勤卡对象可以包含雇员的对象和客户端对象，
和比尔可以包含一个或多个工


Define each object's interfaces Define the formal, syntactic, programming-language-level interfaces to each object. The data and methods the object exposes to every other object is called the object's "public interface." The parts of the object that it exposes to derived objects via inheritance is called the object's "protected interface." Think about both kinds of interfaces.

When you finish going through the steps to achieve a top-level object-oriented system organization, you'll iterate in two ways. You'll iterate on the top-level system organization to get a better organization of classes. You'll also iterate on each of the classes you've defined, driving the design of each class to a more detailed level.

Form Consistent Abstractions
Abstraction is the ability to engage with a concept while safely ignoring some of its details—handling different details at different levels. Any time you work with an aggregate, you're working with an abstraction. If you refer to an object as a "house" rather than a combination of glass, wood, and nails, you're making an abstraction. If you refer to a collection of houses as a "town," you're making another abstraction.

Base classes are abstractions that allow you to focus on common attributes of a set of derived classes and ignore the details of the specific classes while you're working on the base class. A good class interface is an abstraction that allows you to focus on the interface without needing to worry about the internal workings of the class. The interface to a well-designed routine provides the same benefit at a lower level of detail, and the interface to a well-designed package or subsystem provides that benefit at a higher level of detail.

From a complexity point of view, the principal benefit of abstraction is that it allows you to ignore irrelevant details. Most real-world objects are already abstractions of some kind. As just mentioned, a house is an abstraction of windows, doors, siding, wiring, plumbing, insulation, and a particular way of organizing them. A door is in turn an abstraction of a particular arrangement of a rectangular piece of material with hinges and a doorknob. And the doorknob is an abstraction of a particular formation of brass, nickel, iron, or steel.

People use abstraction continuously. If you had to deal with individual wood fibers, varnish molecules, and steel molecules every time you used your front door, you'd hardly make it in or out of your house each day. As Figure 5-7 suggests, abstraction is a big part of how we deal with complexity in the real world.


Figure 5-7. Abstraction allows you to take a simpler view of a complex concept

[View full size image]





Software developers sometimes build systems at the wood-fiber, varnish-molecule, and steel-molecule level. This makes the systems overly complex and intellectually hard to manage. When programmers fail to provide larger programming abstractions, the system itself sometimes fails to make it through the front door.

Cross-Reference

For more details on abstraction in class design, see "Good Abstraction" in Section 6.2.



Good programmers create abstractions at the routine-interface level, class-interface level, and package-interface level—in other words, the doorknob level, door level, and house level—and that supports faster and safer programming.

Encapsulate Implementation Details
Encapsulation picks up where abstraction leaves off. Abstraction says, "You're allowed to look at an object at a high level of detail." Encapsulation says, "Furthermore, you aren't allowed to look at an object at any other level of detail."

Continuing with the housing-materials analogy: encapsulation is a way of saying that you can look at the outside of the house but you can't get close enough to make out the door's details. You are allowed to know that there's a door, and you're allowed to know whether the door is open or closed, but you're not allowed to know whether the door is made of wood, fiberglass, steel, or some other material, and you're certainly not allowed to look at each individual wood fiber.

As Figure 5-8 suggests, encapsulation helps to manage complexity by forbidding you to look at the complexity. The section titled "Good Encapsulation" in Section 6.2 provides more background on encapsulation as it applies to class design.


Figure 5-8. Encapsulation says that, not only are you allowed to take a simpler view of a complex concept, you are not allowed to look at any of the details of the complex concept. What you see is what you get—it's all you get!

[View full size image]





Inherit—When Inheritance Simplifies the Design
In designing a software system, you'll often find objects that are much like other objects, except for a few differences. In an accounting system, for instance, you might have both full-time and part-time employees. Most of the data associated with both kinds of employees is the same, but some is different. In object-oriented programming, you can define a general type of employee and then define full-time employees as general employees, except for a few differences, and part-time employees also as general employees, except for a few differences. When an operation on an employee doesn't depend on the type of employee, the operation is handled as if the employee were just a general employee. When the operation depends on whether the employee is full-time or part-time, the operation is handled differently.

Defining similarities and differences among such objects is called "inheritance" because the specific part-time and full-time employees inherit characteristics from the general-employee type.

The benefit of inheritance is that it works synergistically with the notion of abstraction. Abstraction deals with objects at different levels of detail. Recall the door that was a collection of certain kinds of molecules at one level, a collection of wood fibers at the next, and something that keeps burglars out of your house at the next level. Wood has certain properties—for example, you can cut it with a saw or glue it with wood glue—and two-by-fours or cedar shingles have the general properties of wood as well as some specific properties of their own.

Inheritance simplifies programming because you write a general routine to handle anything that depends on a door's general properties and then write specific routines to handle specific operations on specific kinds of doors. Some operations, such as Open() or Close(), might apply regardless of whether the door is a solid door, interior door, exterior door, screen door, French door, or sliding glass door. The ability of a language to support operations like Open() or Close() without knowing until run time what kind of door you're dealing with is called "polymorphism." Object-oriented languages such as C++, Java, and later versions of Microsoft Visual Basic support inheritance and polymorphism.

Inheritance is one of object-oriented programming's most powerful tools. It can provide great benefits when used well, and it can do great damage when used naively. For details, see "Inheritance ("is a" Relationships)?" in Section 6.3.

Hide Secrets (Information Hiding)
Information hiding is part of the foundation of both structured design and object-oriented design. In structured design, the notion of "black boxes" comes from information hiding. In object-oriented design, it gives rise to the concepts of encapsulation and modularity and it is associated with the concept of abstraction. Information hiding is one of the seminal ideas in software development, and so this subsection explores it in depth.

Information hiding first came to public attention in a paper published by David Parnas in 1972 called "On the Criteria to Be Used in Decomposing Systems Into Modules." Information hiding is characterized by the idea of "secrets," design and implementation decisions that a software developer hides in one place from the rest of a program.

In the 20th Anniversary edition of The Mythical Man Month, Fred Brooks concluded that his criticism of information hiding was one of the few ways in which the first edition of his book was wrong. "Parnas was right, and I was wrong about information hiding," he proclaimed (Brooks 1995). Barry Boehm reported that information hiding was a powerful technique for eliminating rework, and he pointed out that it was particularly effective in incremental, high-change environments (Boehm 1987).

Information hiding is a particularly powerful heuristic for Software's Primary Technical Imperative because, beginning with its name and throughout its details, it emphasizes hiding complexity.

Secrets and the Right to Privacy
In information hiding, each class (or package or routine) is characterized by the design or construction decisions that it hides from all other classes. The secret might be an area that's likely to change, the format of a file, the way a data type is implemented, or an area that needs to be walled off from the rest of the program so that errors in that area cause as little damage as possible. The class's job is to keep this information hidden and to protect its own right to privacy. Minor changes to a system might affect several routines within a class, but they should not ripple beyond the class interface.

One key task in designing a class is deciding which features should be known outside the class and which should remain secret. A class might use 25 routines and expose only 5 of them, using the other 20 internally. A class might use several data types and expose no information about them. This aspect of class design is also known as "visibility" since it has to do with which features of the class are "visible" or "exposed" outside the class.

Strive for class interfaces that are complete and minimal.

—Scott Meyers

The interface to a class should reveal as little as possible about its inner workings. As shown in Figure 5-9, a class is a lot like an iceberg: seven-eighths is under water, and you can see only the one-eighth that's above the surface.


Figure 5-9. A good class interface is like the tip of an iceberg, leaving most of the class unexposed

[View full size image]





Designing the class interface is an iterative process just like any other aspect of design. If you don't get the interface right the first time, try a few more times until it stabilizes. If it doesn't stabilize, you need to try a different approach.

An Example of Information Hiding
Suppose you have a program in which each object is supposed to have a unique ID stored in a member variable called id. One design approach would be to use integers for the IDs and to store the highest ID assigned so far in a global variable called g_maxId. As each new object is allocated, perhaps in each object's constructor, you could simply use the id = ++g_maxId statement, which would guarantee a unique id, and it would add the absolute minimum of code in each place an object is created. What could go wrong with that?

A lot of things could go wrong. What if you want to reserve ranges of IDs for special purposes? What if you want to use nonsequential IDs to improve security? What if you want to be able to reuse the IDs of objects that have been destroyed? What if you want to add an assertion that fires when you allocate more IDs than the maximum number you've anticipated? If you allocated IDs by spreading id = ++g_maxId statements throughout your program, you would have to change code associated with every one of those statements. And, if your program is multithreaded, this approach won't be thread-safe.

The way that new IDs are created is a design decision that you should hide. If you use the phrase ++g_maxId throughout your program, you expose the way a new ID is created, which is simply by incrementing g_maxId. If instead you put the id = NewId() statement throughout your program, you hide the information about how new IDs are created. Inside the NewId() routine you might still have just one line of code, return ( ++g_maxId ) or its equivalent, but if you later decide to reserve certain ranges of IDs for special purposes or to reuse old IDs, you could make those changes within the NewId() routine itself—without touching dozens or hundreds of id = NewId() statements. No matter how complicated the revisions inside NewId() might become, they wouldn't affect any other part of the program.

Now suppose you discover you need to change the type of the ID from an integer to a string. If you've spread variable declarations like int id throughout your program, your use of the NewId() routine won't help. You'll still have to go through your program and make dozens or hundreds of changes.

An additional secret to hide is the ID's type. By exposing the fact that IDs are integers, you encourage programmers to perform integer operations like >, <, = on them. In C++, you could use a simple typedef to declare your IDs to be of IdType—a userdefined type that resolves to int—rather than directly declaring them to be of type int. Alternatively, in C++ and other languages you could create a simple IdType class. Once again, hiding a design decision makes a huge difference in the amount of code affected by a change.

Information hiding is useful at all levels of design, from the use of named constants instead of literals, to creation of data types, to class design, routine design, and subsystem design.



Two Categories of Secrets
Secrets in information hiding fall into two general camps:

Hiding complexity so that your brain doesn't have to deal with it unless you're specifically concerned with it

Hiding sources of change so that when change occurs, the effects are localized

Sources of complexity include complicated data types, file structures, boolean tests, involved algorithms, and so on. A comprehensive list of sources of change is described later in this chapter.

Barriers to Information Hiding
In a few instances, information hiding is truly impossible, but most of the barriers to information hiding are mental blocks built up from the habitual use of other techniques.

Further Reading

Parts of this section are adapted from "Designing Software for Ease of Extension and Contraction" (Parnas 1979).



Excessive distribution of information One common barrier to information hiding is an excessive distribution of information throughout a system. You might have hard-coded the literal 100 throughout a system. Using 100 as a literal decentralizes references to it. It's better to hide the information in one place, in a constant MAX_EMPLOYEES perhaps, whose value is changed in only one place.

Another example of excessive information distribution is interleaving interaction with human users throughout a system. If the mode of interaction changes—say, from a GUI interface to a command line interface—virtually all the code will have to be modified. It's better to concentrate user interaction in a single class, package, or subsystem you can change without affecting the whole system.

Yet another example would be a global data element—perhaps an array of employee data with 1000 elements maximum that's accessed throughout a program. If the program uses the global data directly, information about the data item's implementation—such as the fact that it's an array and has a maximum of 1000 elements—will be spread throughout the program. If the program uses the data only through access routines, only the access routines will know the implementation details.

Cross-Reference

For more on accessing global data through class interfaces, see "Using Access Routines Instead of Global Data" in Section 13.3.



Circular dependencies A more subtle barrier to information hiding is circular dependencies, as when a routine in class A calls a routine in class B, and a routine in class B calls a routine in class A.

Avoid such dependency loops. They make it hard to test a system because you can't test either class A or class B until at least part of the other is ready.

Class data mistaken for global data If you're a conscientious programmer, one of the barriers to effective information hiding might be thinking of class data as global data and avoiding it because you want to avoid the problems associated with global data. While the road to programming hell is paved with global variables, class data presents far fewer risks.

Global data is generally subject to two problems: routines operate on global data without knowing that other routines are operating on it, and routines are aware that other routines are operating on the global data but they don't know exactly what they're doing to it. Class data isn't subject to either of these problems. Direct access to the data is restricted to a few routines organized into a single class. The routines are aware that other routines operate on the data, and they know exactly which other routines they are.

Of course, this whole discussion assumes that your system makes use of well-designed, small classes. If your program is designed to use huge classes that contain dozens of routines each, the distinction between class data and global data will begin to blur and class data will be subject to many of the same problems as global data.

Perceived performance penalties A final barrier to information hiding can be an attempt to avoid performance penalties at both the architectural and the coding levels. You don't need to worry at either level. At the architectural level, the worry is unnecessary because architecting a system for information hiding doesn't conflict with architecting it for performance. If you keep both information hiding and performance in mind, you can achieve both objectives.

Cross-Reference

Code-level performance optimizations are discussed in Chapter 25, "Code-Tuning Strategies" and Chapter 26, "Code-Tuning Techniques."



The more common worry is at the coding level. The concern is that accessing data items indirectly incurs run-time performance penalties for additional levels of object instantiations, routine calls, and so on. This concern is premature. Until you can measure the system's performance and pinpoint the bottlenecks, the best way to prepare for code-level performance work is to create a highly modular design. When you detect hot spots later, you can optimize individual classes and routines without affecting the rest of the system.

Value of Information Hiding
 Information hiding is one of the few theoretical techniques that has indisputably proven its value in practice, which has been true for a long time (Boehm 1987a). Large programs that use information hiding were found years ago to be easier to modify—by a factor of 4—than programs that don't (Korson and Vaishnavi 1986). Moreover, information hiding is part of the foundation of both structured design and object-oriented design.



Information hiding has unique heuristic power, a unique ability to inspire effective design solutions. Traditional object-oriented design provides the heuristic power of modeling the world in objects, but object thinking wouldn't help you avoid declaring the ID as an int instead of an IdType. The object-oriented designer would ask, "Should an ID be treated as an object?" Depending on the project's coding standards, a "Yes" answer might mean that the programmer has to write a constructor, destructor, copy operator, and assignment operator; comment it all; and place it under configuration control. Most programmers would decide, "No, it isn't worth creating a whole class just for an ID. I'll just use ints."

Note what just happened. A useful design alternative, that of simply hiding the ID's data type, was not even considered. If, instead, the designer had asked, "What about the ID should be hidden?" he might well have decided to hide its type behind a simple type declaration that substitutes IdType for int. The difference between object-oriented design and information hiding in this example is more subtle than a clash of explicit rules and regulations. Object-oriented design would approve of this design decision as much as information hiding would. Rather, the difference is one of heuristics—thinking about information hiding inspires and promotes design decisions that thinking about objects does not.

Information hiding can also be useful in designing a class's public interface. The gap between theory and practice in class design is wide, and among many class designers the decision about what to put into a class's public interface amounts to deciding what interface would be the most convenient to use, which usually results in exposing as much of the class as possible. From what I've seen, some programmers would rather expose all of a class's private data than write 10 extra lines of code to keep the class's secrets intact.

Asking "What does this class need to hide?" cuts to the heart of the interface-design issue. If you can put a function or data into the class's public interface without compromising its secrets, do. Otherwise, don't.

Asking about what needs to be hidden supports good design decisions at all levels. It promotes the use of named constants instead of literals at the construction level. It helps in creating good routine and parameter names inside classes. It guides decisions about class and subsystem decompositions and interconnections at the system level.

Get into the habit of asking "What should I hide?" You'll be surprised at how many difficult design issues dissolve before your eyes.



Identify Areas Likely to Change
A study of great designers found that one attribute they had in common was their ability to anticipate change (Glass 1995). Accommodating changes is one of the most challenging aspects of good program design. The goal is to isolate unstable areas so that the effect of a change will be limited to one routine, class, or package. Here are the steps you should follow in preparing for such perturbations.

Further Reading

The approach described in this section is adapted from "Designing Software for Ease of Extension and Contraction" (Parnas 1979).



Identify items that seem likely to change. If the requirements have been done well, they include a list of potential changes and the likelihood of each change. In such a case, identifying the likely changes is easy. If the requirements don't cover potential changes, see the discussion that follows of areas that are likely to change on any project.

Separate items that are likely to change. Compartmentalize each volatile component identified in step 1 into its own class or into a class with other volatile components that are likely to change at the same time.

Isolate items that seem likely to change. Design the interclass interfaces to be insensitive to the potential changes. Design the interfaces so that changes are limited to the inside of the class and the outside remains unaffected. Any other class using the changed class should be unaware that the change has occurred. The class's interface should protect its secrets.

Here are a few areas that are likely to change:

Business rules Business rules tend to be the source of frequent software changes. Congress changes the tax structure, a union renegotiates its contract, or an insurance company changes its rate tables. If you follow the principle of information hiding, logic based on these rules won't be strewn throughout your program. The logic will stay hidden in a single dark corner of the system until it needs to be changed.

Cross-Reference

One of the most powerful techniques for anticipating change is to use table-driven methods. For details, see Chapter 18, "Table-Driven Methods."



Hardware dependencies Examples of hardware dependencies include interfaces to screens, printers, keyboards, mice, disk drives, sound facilities, and communications devices. Isolate hardware dependencies in their own subsystem or class. Isolating such dependencies helps when you move the program to a new hardware environment. It also helps initially when you're developing a program for volatile hardware. You can write software that simulates interaction with specific hardware, have the hardware-interface subsystem use the simulator as long as the hardware is unstable or unavailable, and then unplug the hardware-interface subsystem from the simulator and plug the subsystem into the hardware when it's ready to use.

Input and output At a slightly higher level of design than raw hardware interfaces, input/output is a volatile area. If your application creates its own data files, the file format will probably change as your application becomes more sophisticated. User-level input and output formats will also change—the positioning of fields on the page, the number of fields on each page, the sequence of fields, and so on. In general, it's a good idea to examine all external interfaces for possible changes.

Nonstandard language features Most language implementations contain handy, nonstandard extensions. Using the extensions is a double-edged sword because they might not be available in a different environment, whether the different environment is different hardware, a different vendor's implementation of the language, or a new version of the language from the same vendor.

If you use nonstandard extensions to your programming language, hide those extensions in a class of their own so that you can replace them with your own code when you move to a different environment. Likewise, if you use library routines that aren't available in all environments, hide the actual library routines behind an interface that works just as well in another environment.

Difficult design and construction areas It's a good idea to hide difficult design and construction areas because they might be done poorly and you might need to do them again. Compartmentalize them and minimize the impact their bad design or construction might have on the rest of the system.

Status variables Status variables indicate the state of a program and tend to be changed more frequently than most other data. In a typical scenario, you might originally define an error-status variable as a boolean variable and decide later that it would be better implemented as an enumerated type with the values ErrorType_None, ErrorType_Warning, and ErrorType_Fatal.

You can add at least two levels of flexibility and readability to your use of status variables:

Don't use a boolean variable as a status variable. Use an enumerated type instead. It's common to add a new state to a status variable, and adding a new type to an enumerated type requires a mere recompilation rather than a major revision of every line of code that checks the variable.

Use access routines rather than checking the variable directly. By checking the access routine rather than the variable, you allow for the possibility of more sophisticated state detection. For example, if you wanted to check combinations of an error-state variable and a current-function-state variable, it would be easy to do if the test were hidden in a routine and hard to do if it were a complicated test hard-coded throughout the program.

Data-size constraints When you declare an array of size 100, you're exposing information to the world that the world doesn't need to see. Defend your right to privacy! Information hiding isn't always as complicated as a whole class. Sometimes it's as simple as using a named constant such as MAX_EMPLOYEES to hide a 100.

Anticipating Different Degrees of Change
When thinking about potential changes to a system, design the system so that the effect or scope of the change is proportional to the chance that the change will occur. If a change is likely, make sure that the system can accommodate it easily. Only extremely unlikely changes should be allowed to have drastic consequences for more than one class in a system. Good designers also factor in the cost of anticipating change. If a change is not terribly likely but easy to plan for, you should think harder about anticipating it than if it isn't very likely and is difficult to plan for.

Cross-Reference

This section's approach to anticipating change does not involve designing ahead or coding ahead. For a discussion of those practices, see "A program contains code that seems like it might be needed someday" in Section 24.2.



A good technique for identifying areas likely to change is first to identify the minimal subset of the program that might be of use to the user. The subset makes up the core of the system and is unlikely to change. Next, define minimal increments to the system. They can be so small that they seem trivial. As you consider functional changes, be sure also to consider qualitative changes: making the program thread-safe, making it localizable, and so on. These areas of potential improvement constitute potential changes to the system; design these areas using the principles of information hiding. By identifying the core first, you can see which components are really add-ons and then extrapolate and hide improvements from there.

Further Reading

This discussion draws on the approach described in "On the design and development of program families" (Parnas 1976).



Keep Coupling Loose
Coupling describes how tightly a class or routine is related to other classes or routines. The goal is to create classes and routines with small, direct, visible, and flexible relations to other classes and routines, which is known as "loose coupling." The concept of coupling applies equally to classes and routines, so for the rest of this discussion I'll use the word "module" to refer to both classes and routines.

Good coupling between modules is loose enough that one module can easily be used by other modules. Model railroad cars are coupled by opposing hooks that latch when pushed together. Connecting two cars is easy—you just push the cars together. Imagine how much more difficult it would be if you had to screw things together, or connect a set of wires, or if you could connect only certain kinds of cars to certain other kinds of cars. The coupling of model railroad cars works because it's as simple as possible. In software, make the connections among modules as simple as possible.

Try to create modules that depend little on other modules. Make them detached, as business associates are, rather than attached, as Siamese twins are. A routine like sin() is loosely coupled because everything it needs to know is passed in to it with one value representing an angle in degrees. A routine such as InitVars( var 1, var2, var3, …, varN ) is more tightly coupled because, with all the variables it must pass, the calling module practically knows what is happening inside InitVars(). Two classes that depend on each other's use of the same global data are even more tightly coupled.

Coupling Criteria
Here are several criteria to use in evaluating coupling between modules:

Size Size refers to the number of connections between modules. With coupling, small is beautiful because it's less work to connect other modules to a module that has a smaller interface. A routine that takes one parameter is more loosely coupled to modules that call it than a routine that takes six parameters. A class with four well-defined public methods is more loosely coupled to modules that use it than a class that exposes 37 public methods.

Visibility Visibility refers to the prominence of the connection between two modules. Programming is not like being in the CIA; you don't get credit for being sneaky. It's more like advertising; you get lots of credit for making your connections as blatant as possible. Passing data in a parameter list is making an obvious connection and is therefore good. Modifying global data so that another module can use that data is a sneaky connection and is therefore bad. Documenting the global-data connection makes it more obvious and is slightly better.

Flexibility Flexibility refers to how easily you can change the connections between modules. Ideally, you want something more like the USB connector on your computer than like bare wire and a soldering gun. Flexibility is partly a product of the other coupling characteristics, but it's a little different too. Suppose you have a routine that looks up the amount of vacation an employee receives each year, given a hiring date and a job classification. Name the routine LookupVacationBenefit(). Suppose in another module you have an employee object that contains the hiring date and the job classification, among other things, and that module passes the object to LookupVacationBenefit().

From the point of view of the other criteria, the two modules would look loosely coupled. The employee connection between the two modules is visible, and there's only one connection. Now suppose that you need to use the LookupVacationBenefit() module from a third module that doesn't have an employee object but that does have a hiring date and a job classification. Suddenly LookupVacationBenefit() looks less friendly, unwilling to associate with the new module.

For the third module to use LookupVacationBenefit(), it has to know about the Employee class. It could dummy up an employee object with only two fields, but that would require internal knowledge of LookupVacationBenefit(), namely that those are the only fields it uses. Such a solution would be a kludge, and an ugly one. The second option would be to modify LookupVacationBenefit() so that it would take hiring date and job classification instead of employee. In either case, the original module turns out to be a lot less flexible than it seemed to be at first.

The happy ending to the story is that an unfriendly module can make friends if it's willing to be flexible—in this case, by changing to take hiring date and job classification specifically instead of employee.

In short, the more easily other modules can call a module, the more loosely coupled it is, and that's good because it's more flexible and maintainable. In creating a system structure, break up the program along the lines of minimal interconnectedness. If a program were a piece of wood, you would try to split it with the grain.

Kinds of Coupling
Here are the most common kinds of coupling you'll encounter.

Simple-data-parameter coupling Two modules are simple-data-parameter coupled if all the data passed between them are of primitive data types and all the data is passed through parameter lists. This kind of coupling is normal and acceptable.

Simple-object coupling A module is simple-object coupled to an object if it instantiates that object. This kind of coupling is fine.

Object-parameter coupling Two modules are object-parameter coupled to each other if Object1 requires Object2 to pass it an Object3. This kind of coupling is tighter than Object1 requiring Object2 to pass it only primitive data types because it requires Object2 to know about Object3.

Semantic coupling The most insidious kind of coupling occurs when one module makes use not of some syntactic element of another module but of some semantic knowledge of another module's inner workings. Here are some examples:

Module1 passes a control flag to Module2 that tells Module2 what to do. This approach requires Module1 to make assumptions about the internal workings of Module2, namely what Module2 is going to do with the control flag. If Module2 defines a specific data type for the control flag (enumerated type or object), this usage is probably OK.

Module2 uses global data after the global data has been modified by Module1. This approach requires Module2 to assume that Module1 has modified the data in the ways Module2 needs it to be modified, and that Module1 has been called at the right time.

Module1's interface states that its Module1.Initialize() routine should be called before its Module1.Routine() is called. Module2 knows that Module1.Routine() calls Module1.Initialize() anyway, so it just instantiates Module1 and calls Module1.Routine() without calling Module1.Initialize() first.

Module1 passes Object to Module2. Because Module1 knows that Module2 uses only three of Object's seven methods, it initializes Object only partially—with the specific data those three methods need.

Module1 passes BaseObject to Module2. Because Module2 knows that Module1 is really passing it DerivedObject, it casts BaseObject to DerivedObject and calls methods that are specific to DerivedObject.

Semantic coupling is dangerous because changing code in the used module can break code in the using module in ways that are completely undetectable by the compiler. When code like this breaks, it breaks in subtle ways that seem unrelated to the change made in the used module, which turns debugging into a Sisyphean task.

The point of loose coupling is that an effective module provides an additional level of abstraction—once you write it, you can take it for granted. It reduces overall program complexity and allows you to focus on one thing at a time. If using a module requires you to focus on more than one thing at once—knowledge of its internal workings, modification to global data, uncertain functionality—the abstractive power is lost and the module's ability to help manage complexity is reduced or eliminated.

 Classes and routines are first and foremost intellectual tools for reducing complexity. If they're not making your job simpler, they're not doing their jobs.



Look for Common Design Patterns
cc2e.com/0585

Design patterns provide the cores of ready-made solutions that can be used to solve many of software's most common problems. Some software problems require solutions that are derived from first principles. But most problems are similar to past problems, and those can be solved using similar solutions, or patterns. Common patterns include Adapter, Bridge, Decorator, Facade, Factory Method, Observor, Singleton, Strategy, and Template Method. The book Design Patterns by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (1995) is the definitive description of design patterns.

Patterns provide several benefits that fully custom design doesn't:

Patterns reduce complexity by providing ready-made abstractions If you say, "This code uses a Factory Method to create instances of derived classes," other programmers on your project will understand that your code involves a fairly rich set of interrelationships and programming protocols, all of which are invoked when you refer to the design pattern of Factory Method.

The Factory Method is a pattern that allows you to instantiate any class derived from a specific base class without needing to keep track of the individual derived classes anywhere but the Factory Method. For a good discussion of the Factory Method pattern, see "Replace Constructor with Factory Method" in Refactoring (Fowler 1999).

You don't have to spell out every line of code for other programmers to understand the design approach found in your code.

Patterns reduce errors by institutionalizing details of common solutions Software design problems contain nuances that emerge fully only after the problem has been solved once or twice (or three times, or four times, or…). Because patterns represent standardized ways of solving common problems, they embody the wisdom accumulated from years of attempting to solve those problems, and they also embody the corrections to the false attempts that people have made in solving those problems.

Using a design pattern is thus conceptually similar to using library code instead of writing your own. Sure, everybody has written a custom Quicksort a few times, but what are the odds that your custom version will be fully correct on the first try? Similarly, numerous design problems are similar enough to past problems that you're better off using a prebuilt design solution than creating a novel solution.

Patterns provide heuristic value by suggesting design alternatives A designer who's familiar with common patterns can easily run through a list of patterns and ask "Which of these patterns fits my design problem?" Cycling through a set of familiar alternatives is immeasurably easier than creating a custom design solution out of whole cloth. And the code arising from a familiar pattern will also be easier for readers of the code to understand than fully custom code would be.

Patterns streamline communication by moving the design dialog to a higher level In addition to their complexity-management benefit, design patterns can accelerate design discussions by allowing designers to think and discuss at a larger level of granularity. If you say "I can't decide whether I should use a Creator or a Factory Method in this situation," you've communicated a great deal with just a few words—as long as you and your listener are both familiar with those patterns. Imagine how much longer it would take you to dive into the details of the code for a Creator pattern and the code for a Factory Method pattern and then compare and contrast the two approaches.

If you're not already familiar with design patterns, Table 5-1 summarizes some of the most common patterns to stimulate your interest.

Table 5-1. Popular Design Patterns Pattern
 Description

Abstract Factory
Supports creation of sets of related objects by specifying the kind of set but not the kinds of each specific object.

Adapter
 Converts the interface of a class to a different interface.

Bridge
 Builds an interface and an implementation in such a way that either can vary without the other varying.

Composite
 Consists of an object that contains additional objects of its own type so that client code can interact with the top-level object and not concern itself with all the detailed objects.

Decorator
 Attaches responsibilities to an object dynamically, without creating specific subclasses for each possible configuration of responsibilities.

Facade
 Provides a consistent interface to code that wouldn't otherwise offer a consistent interface.

Factory Method
 Instantiates classes derived from a specific base class without needing to keep track of the individual derived classes anywhere but the Factory Method.

Iterator
 A server object that provides access to each element in a set sequentially.

Observer
 Keeps multiple objects in synch with one another by making an object responsible for notifying the set of related objects about changes to any member of the set.

Singleton
 Provides global access to a class that has one and only one instance.

Strategy
 Defines a set of algorithms or behaviors that are dynamically interchangeable with each other.

Template Method
 Defines the structure of an algorithm but leaves some of the detailed implementation to subclasses.





If you haven't seen design patterns before, your reaction to the descriptions in Table 5-1 might be "Sure, I already know most of these ideas." That reaction is a big part of why design patterns are valuable. Patterns are familiar to most experienced programmers, and assigning recognizable names to them supports efficient and effective communication about them.

One potential trap with patterns is force-fitting code to use a pattern. In some cases, shifting code slightly to conform to a well-recognized pattern will improve understandability of the code. But if the code has to be shifted too far, forcing it to look like a standard pattern can sometimes increase complexity.

Another potential trap with patterns is feature-itis: using a pattern because of a desire to try out a pattern rather than because the pattern is an appropriate design solution.

Overall, design patterns are a powerful tool for managing complexity. You can read more detailed descriptions in any of the good books that are listed at the end of this chapter.

Other Heuristics
The preceding sections describe the major software design heuristics. Following are a few other heuristics that might not be useful quite as often but are still worth mentioning.

Aim for Strong Cohesion
        Cohesion arose from structured design and is usually discussed in the same context as coupling. Cohesion refers to how closely all the routines in a class or all the code in a routine support a central purpose—how focused the class is. Classes that contain strongly related functionality are described as having strong cohesion, and the heuristic goal is to make cohesion as strong as possible. Cohesion is a useful tool for managing complexity because the more that code in a class supports a central purpose, the more easily your brain can remember everything the code does.

Thinking about cohesion at the routine level has been a useful heuristic for decades and is still useful today. At the class level, the heuristic of cohesion has largely been subsumed by the broader heuristic of well-defined abstractions, which was discussed earlier in this chapter and in Chapter 6. Abstractions are useful at the routine level, too, but on a more even footing with cohesion at that level of detail.

Build Hierarchies
A hierarchy is a tiered information structure in which the most general or abstract representation of concepts is contained at the top of the hierarchy, with increasingly detailed, specialized representations at the hierarchy's lower levels. In software, hierarchies are found in class hierarchies, and, as Level 4 in Figure 5-2 illustrated, in routine-calling hierarchies as well.

Hierarchies have been an important tool for managing complex sets of information for at least 2000 years. Aristotle used a hierarchy to organize the animal kingdom. Humans frequently use outlines to organize complex information (like this book). Researchers have found that people generally find hierarchies to be a natural way to organize complex information. When they draw a complex object such as a house, they draw it hierarchically. First they draw the outline of the house, then the windows and doors, and then more details. They don't draw the house brick by brick, shingle by shingle, or nail by nail (Simon 1996).

Hierarchies are a useful tool for achieving Software's Primary Technical Imperative because they allow you to focus on only the level of detail you're currently concerned with. The details don't go away completely; they're simply pushed to another level so that you can think about them when you want to rather than thinking about all the details all of the time.

Formalize Class Contracts
At a more detailed level, thinking of each class's interface as a contract with the rest of the program can yield good insights. Typically, the contract is something like "If you promise to provide data x, y, and z and you promise they'll have characteristics a, b, and c, I promise to perform operations 1, 2, and 3 within constraints 8, 9, and 10." The promises the clients of the class make to the class are typically called "preconditions," and the promises the object makes to its clients are called the "postconditions."

Cross-Reference

For more on contracts, see "Use assertions to document and verify preconditions and postconditions" in Section 8.2.



Contracts are useful for managing complexity because, at least in theory, the object can safely ignore any noncontractual behavior. In practice, this issue is much more difficult.

Assign Responsibilities
Another heuristic is to think through how responsibilities should be assigned to objects. Asking what each object should be responsible for is similar to asking what information it should hide, but I think it can produce broader answers, which gives the heuristic unique value.

Design for Test
A thought process that can yield interesting design insights is to ask what the system will look like if you design it to facilitate testing. Do you need to separate the user interface from the rest of the code so that you can exercise it independently? Do you need to organize each subsystem so that it minimizes dependencies on other subsystems? Designing for test tends to result in more formalized class interfaces, which is generally beneficial.

Avoid Failure
Civil engineering professor Henry Petroski wrote an interesting book, Design Paradigms: Case Histories of Error and Judgment in Engineering (Petroski 1994), that chronicles the history of failures in bridge design. Petroski argues that many spectacular bridge failures have occurred because of focusing on previous successes and not adequately considering possible failure modes. He concludes that failures like the Tacoma Narrows bridge could have been avoided if the designers had carefully considered the ways the bridge might fail and not just copied the attributes of other successful designs.

The high-profile security lapses of various well-known systems the past few years make it hard to disagree that we should find ways to apply Petroski's design-failure insights to software.

Choose Binding Time Consciously
Binding time refers to the time a specific value is bound to a variable. Code that binds early tends to be simpler, but it also tends to be less flexible. Sometimes you can get a good design insight from asking questions like these: What if I bound these values earlier? What if I bound these values later? What if I initialized this table right here in the code? What if I read the value of this variable from the user at run time?

Cross-Reference

For more on binding time, see Section 10.6, "Binding Time."



Make Central Points of Control
P.J. Plauger says his major concern is "The Principle of One Right Place—there should be One Right Place to look for any nontrivial piece of code, and One Right Place to make a likely maintenance change" (Plauger 1993). Control can be centralized in classes, routines, preprocessor macros, #include files—even a named constant is an example of a central point of control.

The reduced-complexity benefit is that the fewer places you have to look for something, the easier and safer it will be to change.

Consider Using Brute Force
One powerful heuristic tool is brute force. Don't underestimate it. A brute-force solution that works is better than an elegant solution that doesn't work. It can take a long time to get an elegant solution to work. In describing the history of searching algorithms, for example, Donald Knuth pointed out that even though the first description of a binary search algorithm was published in 1946, it took another 16 years for someone to publish an algorithm that correctly searched lists of all sizes (Knuth 1998). A binary search is more elegant, but a brute-force, sequential search is often sufficient.

When in doubt, use brute force.

—Butler Lampson

Draw a Diagram
Diagrams are another powerful heuristic tool. A picture is worth 1000 words—kind of. You actually want to leave out most of the 1000 words because one point of using a picture is that a picture can represent the problem at a higher level of abstraction. Sometimes you want to deal with the problem in detail, but other times you want to be able to work with more generality.

Keep Your Design Modular
Modularity's goal is to make each routine or class like a "black box": You know what goes in, and you know what comes out, but you don't know what happens inside. A black box has such a simple interface and such well-defined functionality that for any specific input you can accurately predict the corresponding output.

The concept of modularity is related to information hiding, encapsulation, and other design heuristics. But sometimes thinking about how to assemble a system from a set of black boxes provides insights that information hiding and encapsulation don't, so the concept is worth having in your back pocket.

Summary of Design Heuristics
Here's a summary of major design heuristics:

More alarming, the same programmer is quite capable of doing the same task himself in two or three ways, sometimes unconsciously, but quite often simply for a change, or to provide elegant variation.

—A. R. Brown and W. A. Sampson

Find Real-World Objects

Form Consistent Abstractions

Encapsulate Implementation Details

Inherit When Possible

Hide Secrets (Information Hiding)

Identify Areas Likely to Change

Keep Coupling Loose

Look for Common Design Patterns

The following heuristics are sometimes useful too:

Aim for Strong Cohesion

Build Hierarchies

Formalize Class Contracts

Assign Responsibilities

Design for Test

Avoid Failure

Choose Binding Time Consciously

Make Central Points of Control

Consider Using Brute Force

Draw a Diagram

Keep Your Design Modular

Guidelines for Using Heuristics
Approaches to design in software can learn from approaches to design in other fields. One of the original books on heuristics in problem solving was G. Polya's How to Solve It (1957). Polya's generalized problem-solving approach focuses on problem solving in mathematics. Figure 5-10 is a summary of his approach, adapted from a similar summary in his book (emphases his).


Figure 5-10. G. Polya developed an approach to problem solving in mathematics that's also useful in solving problems in software design (Polya 1957)

[View full size image]





cc2e.com/0592

One of the most effective guidelines is not to get stuck on a single approach. If diagramming the design in UML isn't working, write it in English. Write a short test program. Try a completely different approach. Think of a brute-force solution. Keep outlining and sketching with your pencil, and your brain will follow. If all else fails, walk away from the problem. Literally go for a walk, or think about something else before returning to the problem. If you've given it your best and are getting nowhere, putting it out of your mind for a time often produces results more quickly than sheer persistence can.

You don't have to solve the whole design problem at once. If you get stuck, remember that a point needs to be decided but recognize that you don't yet have enough information to resolve that specific issue. Why fight your way through the last 20 percent of the design when it will drop into place easily the next time through? Why make bad decisions based on limited experience with the design when you can make good decisions based on more experience with it later? Some people are uncomfortable if they don't come to closure after a design cycle, but after you have created a few designs without resolving issues prematurely, it will seem natural to leave issues unresolved until you have more information (Zahniser 1992, Beck 2000).

Previous Section   < Free Open Study >   Next Section



?>



/*
Good design depends on understanding a handful of key concepts. This section discusses the role of complexity, desirable characteristics of designs, and levels of design.
Software's Primary Technical Imperative: Managing Complexity (n.复杂性，错综复杂的状态;复杂的事物;复合物)
好的设计依赖于理解几个关键概念，如这一部分讨论“复杂性（complexity）”，“设计所需的特性”和“设计的层次”这些概念。软件主要的技术性必要因素：管理复杂性。
To understand the importance of managing complexity, it's useful to refer to Fred Brooks's landmark paper, "No Silver Bullets: Essence and Accidents of Software Engineering" (1987).
为了理解 managing complexity的重要性，就不得不提 Fred Brooks的具有里程碑意义的论文：No Silver Bullets: Essence and Accidents of Software Engineering(1987)
    Cross-Reference  参照
        For discussion of the way complexity affects programming issues other than design, see Section 34.1, "Conquer Complexity."
        complexity比其他设计要点更影响编程的讨论，请查看 section 34.1 "征服complexity"

Accidental and Essential Difficulties   偶然和必然的困境。
    Brooks argues that software development is made difficult because of two different classes of problems—the essential and the accidental.
In referring to these two terms, Brooks draws on a philosophical tradition going back to Aristotle. In philosophy, the essential properties are the properties that a thing must have in order to be that thing.
A car must have an engine, wheels, and doors to be a car. If it doesn't have any of those essential properties, it isn't really a car.
Accidental properties are the properties a thing just happens to have, properties that don't really bear on whether the thing is what it is. A car could have a V8, a turbocharged 4-cylinder, or some other kind of
engine and be a car regardless of that detail. A car could have two doors or four; it could have skinny wheels or mag wheels. All those details are accidental properties. You could also think of
accidental properties as incidental, discretionary, optional, and happenstance.
    Brooks认为说软件开发是困难的。因为这里有两类问题--事物的必然属性和偶然属性。在谈到这两个问题的时候，Brooks借用了一个可以追溯到古罗马时期的哲学术语。在哲学领域，必然属性是一个事物之所以称之为此事物的必不可少的属性，例如一个汽车必须要有
引擎、轮子和车门，这样才能被称之为汽车。如果它没有这些必然属性中的任何一个，它就不能被称之为汽车。偶然属性是一个事物恰好有的（没有也没有关系)属性，它们并不决定这个事物是什么，例如一个汽车可以有一个V8，或者一个涡轮增压四缸发动机，或者一个其他类型的
发动机和其他一些可忽略的细节。一个汽车可以有两个或者四个门；它可以有什么轮子或者什么轮子---所有这些细节都是偶然属性。你也可以把偶然属性认为是xx,xx,可选的和xx。

Brooks observes that the major accidental difficulties in software were addressed long ago. For example, accidental difficulties related to clumsy language syntaxes were largely eliminated
in the evolution from assembly language to third-generation languages and have declined in significance incrementally since then. Accidental difficulties related to noninteractive
computers were resolved when time-share operating systems replaced batch-mode systems. Integrated programming environments further eliminated inefficiencies in programming work arising from tools that
worked poorly together.

    Brooks指出，在软件中的主要的偶然性困难在很久以前就解决了。例如，从汇编语言到第三代语言的演变过程中，与笨拙的语言的语法相关的非偶然性困难在很大程度上已经消除了，并且从那时起这些困难逐渐显著减少，而当分时操作系统取代批处理模式系统
之后，集成编程环境进一步消除了编程工作中源自胡乱集成在一起的工具的使用中的低效。

    Cross-Reference
        Accidental difficulties are more prominent in early-wave development than in late-wave development. For details, see Section 4.3, "Your Location on the Technology Wave."

Brooks argues that progress on software's remaining essential difficulties is bound to be slower. The reason is that, at its essence, software development consists of working out all the details of a highly
 intricate, interlocking set of concepts. The essential difficulties arise from the necessity of interfacing with the complex, disorderly real world; accurately and completely identifying the dependencies and
exception cases; designing solutions that can't be just approximately correct but that must be exactly correct; and so on. Even if we could invent a programming language that used the same terminology as the
real-world problem we're trying to solve, programming would still be difficult because of the challenge in determining precisely how the real world works. As software addresses ever-larger real-world problems,
 the interactions among the real-world entities become increasingly intricate, and that in turn increases the essential difficulty of the software solutions.
The root of all these essential difficulties is complexity—both accidental and essential.
Brooks认为，剩下的软件中必然性的困难的解决过程必然会很慢。原因是，在其本质上，软件开发由一个高度复杂的、概念互锁的集合，软件开发必须事先其中所有细节。必要性的困难源自于 与复杂的、无序的现实世界的接口的必要性；准确、完全的分辨出依赖关系和例外/异常案例，
设计的解决方案不能只是近似正确的，而是必须是完全正确的等等。即使我们可以发明一种编程语言，使用与我们正在试图解决的现实世界中的问题的相同术语，编程仍然是困难的，因为如何精确确定现实世界是如何运行的依然困难。随着软件解决了越来越大的现实世界的问题
，现实世界中的实体之间的相互作用变得越来越复杂，这反过来又增加了软件解决方案的必然性的难度。所有这些基本困难的根源都是偶然和必然/本质的复杂性。
Importance of Managing Complexity  掌控复杂性的重要性
When software-project surveys report causes of project failure, they rarely identify technical reasons as the primary causes of project failure. Projects fail most often because of poor requirements,
poor planning, or poor management. But when projects do fail for reasons that are primarily technical, the reason is often uncontrolled complexity. The software is allowed to grow so complex that no one
really knows what it does. When a project reaches the point at which no one completely understands the impact that code changes in one area will have on other areas, progress grinds to a halt.
There are two ways of constructing a software design: one way is to make it so simple that there are obviously no deficiencies, and the other is to make it so complicated that there are no obvious deficiencies.
软件失败，技术并非主要原因。而经常是因为需求、计划或者管理。但是当确实是技术原因导致的失败，往往是由复杂性的不可控引起的。软件被允许复杂到谁都不知道它是做什么的。当一个工程达到一个谁都不知道改变一个区域内的代码将带来什么影响的境地，
程序就被迫halt了。
这里有两种方式来构建软件设计方案：一种是简简单单没有缺陷，另一种是复杂至极没有明显缺陷。

—C. A. R. Hoare
 	Managing complexity is the most important technical topic in software development. In my view, it's so important that Software's Primary Technical Imperative has to be managing complexity.
管理复杂性在软件开发中是最重要的技术话题。在我看来，它是如此之重要以至于软件的主要技术必须是管理复杂性。

Complexity is not a new feature of software development. Computing pioneer Edsger Dijkstra pointed out that computing is the only profession in which a single mind is obliged to span the distance from a bit to a few hundred megabytes, a ratio of 1 to 109, or nine orders of magnitude (Dijkstra 1989). This gigantic ratio is staggering. Dijkstra put it this way: "Compared to that number of semantic levels, the average mathematical theory is almost flat. By evoking the need for deep conceptual hierarchies, the automatic computer confronts us with a radically new intellectual challenge that has no precedent in our history." Of course software has become even more complex since 1989, and Dijkstra's ratio of 1 to 109could easily be more like 1 to 1015 today.
Dijkstra pointed out that no one's skull is really big enough to contain a modern computer program (Dijkstra 1972), which means that we as software developers shouldn't try to cram whole programs into our skulls at once; we should try to organize our programs in such a way that we can safely focus on one part of it at a time. The goal is to minimize the amount of a program you have to think about at any one time. You might think of this as mental juggling—the more mental balls the program requires you to keep in the air at once, the more likely you'll drop one of the balls, leading to a design or coding error.
One symptom that you have bogged down in complexity overload is when you find yourself doggedly applying a method that is clearly irrelevant, at least to any outside observer. It is like the mechanically inept person whose car breaks down—so he puts water in the battery and empties the ashtrays.
—P. J. Plauger
At the software-architecture level, the complexity of a problem is reduced by dividing the system into subsystems. Humans have an easier time comprehending several simple pieces of information than one complicated piece. The goal of all software-design techniques is to break a complicated problem into simple pieces. The more independent the subsystems are, the more you make it safe to focus on one bit of complexity at a time. Carefully defined objects separate concerns so that you can focus on one thing at a time. Packages provide the same benefit at a higher level of aggregation.
Keeping routines short helps reduce your mental workload. Writing programs in terms of the problem domain, rather than in terms of low-level implementation details, and working at the highest level of abstraction reduce the load on your brain.
The bottom line is that programmers who compensate for inherent human limitations write code that's easier for themselves and others to understand and that has fewer errors.
How to Attack Complexity
Overly costly, ineffective designs arise from three sources:
•	A complex solution to a simple problem
•	A simple, incorrect solution to a complex problem
•	An inappropriate, complex solution to a complex problem
As Dijkstra pointed out, modern software is inherently complex, and no matter how hard you try, you'll eventually bump into some level of complexity that's inherent in the real-world problem itself. This suggests a two-prong approach to managing complexity:
•	 Minimize the amount of essential complexity that anyone's brain has to deal with at any one time.
•	Keep accidental complexity from needlessly proliferating.
Once you understand that all other technical goals in software are secondary to managing complexity, many design considerations become straightforward.
Desirable Characteristics of a Design
A high-quality design has several general characteristics. If you could achieve all these goals, your design would be very good indeed. Some goals contradict other goals, but that's the challenge of design—creating a good set of tradeoffs from competing objectives. Some characteristics of design quality are also characteristics of a good program: reliability, performance, and so on. Others are internal characteristics of the design.
When I am working on a problem I never think about beauty. I think only how to solve the problem. But when I have finished, if the solution is not beautiful, I know it is wrong.
—R. Buckminster Fuller
Here's a list of internal design characteristics:
Cross-Reference
These characteristics are related to general software-quality attributes. For details on general attributes, see Section 20.1, "Characteristics of Software Quality."

Minimal complexity The primary goal of design should be to minimize complexity for all the reasons just described. Avoid making "clever" designs. Clever designs are usually hard to understand. Instead make "simple" and "easy-to-understand" designs. If your design doesn't let you safely ignore most other parts of the program when you're immersed in one specific part, the design isn't doing its job.
Ease of maintenance Ease of maintenance means designing for the maintenance programmer. Continually imagine the questions a maintenance programmer would ask about the code you're writing. Think of the maintenance programmer as your audience, and then design the system to be self-explanatory.
Loose coupling Loose coupling means designing so that you hold connections among different parts of a program to a minimum. Use the principles of good abstractions in class interfaces, encapsulation, and information hiding to design classes with as few interconnections as possible. Minimal connectedness minimizes work during integration, testing, and maintenance.
Extensibility Extensibility means that you can enhance a system without causing violence to the underlying structure. You can change a piece of a system without affecting other pieces. The most likely changes cause the system the least trauma.
Reusability Reusability means designing the system so that you can reuse pieces of it in other systems.
High fan-in High fan-in refers to having a high number of classes that use a given class. High fan-in implies that a system has been designed to make good use of utility classes at the lower levels in the system.
Low-to-medium fan-out Low-to-medium fan-out means having a given class use a low-to-medium number of other classes. High fan-out (more than about seven) indicates that a class uses a large number of other classes and may therefore be overly complex. Researchers have found that the principle of low fan-out is beneficial whether you're considering the number of routines called from within a routine or from within a class (Card and Glass 1990; Basili, Briand, and Melo 1996).
Portability Portability means designing the system so that you can easily move it to another environment.
Leanness Leanness means designing the system so that it has no extra parts (Wirth 1995, McConnell 1997). Voltaire said that a book is finished not when nothing more can be added but when nothing more can be taken away. In software, this is especially true because extra code has to be developed, reviewed, tested, and considered when the other code is modified. Future versions of the software must remain backward-compatible with the extra code. The fatal question is "It's easy, so what will we hurt by putting it in?"
Stratification Stratification means trying to keep the levels of decomposition stratified so that you can view the system at any single level and get a consistent view. Design the system so that you can view it at one level without dipping into other levels.
For example, if you're writing a modern system that has to use a lot of older, poorly designed code, write a layer of the new system that's responsible for interfacing with the old code. Design the layer so that it hides the poor quality of the old code, presenting a consistent set of services to the newer layers. Then have the rest of the system use those classes rather than the old code. The beneficial effects of stratified design in such a case are (1) it compartmentalizes the messiness of the bad code and (2) if you're ever allowed to jettison the old code or refactor it, you won't need to modify any new code except the interface layer.
Cross-Reference
For more on working with old systems, see Section 24.5, "Refactoring Strategies."

Standard techniques The more a system relies on exotic pieces, the more intimidating it will be for someone trying to understand it the first time. Try to give the whole system a familiar feeling by using standardized, common approaches.
Cross-Reference
An especially valuable kind of standardization is the use of design patterns, which are discussed in "Look for Common Design Patterns" in Section 5.3.

Levels of Design
Design is needed at several different levels of detail in a software system. Some design techniques apply at all levels, and some apply at only one or two. Figure 5-2 illustrates the levels.
Figure 5-2. The levels of design in a program. The system (1) is first organized into subsystems (2). The subsystems are further divided into classes (3), and the classes are divided into routines and data (4). The inside of each routine is also designed (5)
[View full size image]


Level 1: Software System
The first level is the entire system. Some programmers jump right from the system level into designing classes, but it's usually beneficial to think through higher level combinations of classes, such as subsystems or packages.
In other words—and this is the rock-solid principle on which the whole of the Corporation's Galaxywide success is founded—their fundamental design flaws are completely hidden by their superficial design flaws.
—Douglas Adams
Level 2: Division into Subsystems or Packages
The main product of design at this level is the identification of all major subsystems. The subsystems can be big: database, user interface, business rules, command interpreter, report engine, and so on. The major design activity at this level is deciding how to partition the program into major subsystems and defining how each subsystem is allowed to use each other subsystem. Division at this level is typically needed on any project that takes longer than a few weeks. Within each subsystem, different methods of design might be used—choosing the approach that best fits each part of the system. In Figure 5-2, design at this level is marked with a 2.
Of particular importance at this level are the rules about how the various subsystems can communicate. If all subsystems can communicate with all other subsystems, you lose the benefit of separating them at all. Make each subsystem meaningful by restricting communications.
Suppose for example that you define a system with six subsystems, as shown in Figure 5-3. When there are no rules, the second law of thermodynamics will come into play and the entropy of the system will increase. One way in which entropy increases is that, without any restrictions on communications among subsystems, communication will occur in an unrestricted way, as in Figure 5-4.
Figure 5-3. An example of a system with six subsystems
[View full size image]


Figure 5-4. An example of what happens with no restrictions on intersubsystem communications
[View full size image]


As you can see, every subsystem ends up communicating directly with every other subsystem, which raises some important questions:
•	How many different parts of the system does a developer need to understand at least a little bit to change something in the graphics subsystem?
•	What happens when you try to use the business rules in another system?
•	What happens when you want to put a new user interface on the system, perhaps a command-line UI for test purposes?
•	What happens when you want to put data storage on a remote machine?
    You might think of the lines between subsystems as being hoses with water running through them. If you want to reach in and pull out a subsystem, that subsystem is going to have some hoses attached to it. The more hoses you have to disconnect and reconnect, the more wet you're going to get. You want to architect your system so that if you pull out a subsystem to use elsewhere, you won't have many hoses to reconnect and those hoses will reconnect easily.
With forethought, all of these issues can be addressed with little extra work. Allow communication between subsystems only on a "need to know" basis—and it had better be a good reason. If in doubt, it's easier to restrict communication early and relax it later than it is to relax it early and then try to tighten it up after you've coded several hundred intersubsystem calls. Figure 5-5 shows how a few communication guidelines could change the system depicted in Figure 5-4.
Figure 5-5. With a few communication rules, you can simplify subsystem interactions significantly
[View full size image]
